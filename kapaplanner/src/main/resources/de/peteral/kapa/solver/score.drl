package de.peteral.kapa.solver
    dialect "java"

import org.optaplanner.core.api.score.buildin.bendable.BendableScoreHolder;

import de.peteral.kapa.domain.Task
import de.peteral.kapa.domain.SubTask
import de.peteral.kapa.domain.Sprint
import de.peteral.kapa.domain.Team
import de.peteral.kapa.domain.Project
import java.util.stream.Collectors

import function de.peteral.kapa.solver.SolverUtils.getDelayCosts

global BendableScoreHolder scoreHolder;

// Hard constraints

rule "Task dependency must not be violated"
    when
        $task: Task()
        Task(firstSprint != null, previousTasks contains $task, $task.lastSprint != null,
            firstSprint.name.compareTo($task.lastSprint.name) <= 0)
    then
        scoreHolder.addHardConstraintMatch(kcontext, 0, -1);
end

rule "Team must have required skill"
    when
        SubTask(sprint != null, sprint.team.skills not contains task.skill)
    then
        scoreHolder.addHardConstraintMatch(kcontext, 1, -1);
end

rule "Cannot plan above sprint velocity"
    when
        $sprint : Sprint()
        accumulate(
            SubTask(sprint == $sprint, $work : work);
            $total : sum($work);
            $total > $sprint.velocity
        )
    then
        scoreHolder.addHardConstraintMatch(kcontext, 2, -1);
end

rule "Max task velocity per sprint must not be exceeded"
    when
        Task(sprintViolatesMaxVelocity)
    then
        scoreHolder.addHardConstraintMatch(kcontext, 3, -1);
end

rule "Task cannot start before first possible sprint (external dependency)"
    when
        Task(firstPossibleSprint != null, firstSprint != null, firstSprint.name.compareTo(firstPossibleSprint) < 0)
    then
        scoreHolder.addHardConstraintMatch(kcontext, 4, -1);
end

rule "Task must be assigned"
    when
        SubTask(sprint == null)
    then
        scoreHolder.addHardConstraintMatch(kcontext, 5, -1);
end


// one task can be done only in one team
rule "One task can only be done by one team"
    when
        SubTask(sprint != null, $task : task, $team: sprint.team)
        SubTask(sprint != null, task == $task, sprint.team != $team)
    then
        scoreHolder.addHardConstraintMatch(kcontext, 6, -1);
end

// Soft constraints - let's try to make this a hard constraint

rule "Minimize costs of delay"
    when
        Project(costsOfDelay > 0 && due != null && lastSprint != null,
            $due : due, $lastSprint : lastSprint.name, $costs : costsOfDelay)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 0, - getDelayCosts($due, $lastSprint, $costs));
end

// proper sprint utilitation seems to work without any rules

// do we need fair workload balance constraint?

// TODO tasks should not be split into too many sprints